{"ast":null,"code":"/*!\n * morgan\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = morgan;\nmodule.exports.compile = compile;\nmodule.exports.format = format;\nmodule.exports.token = token;\n/**\n * Module dependencies.\n * @private\n */\n\nvar auth = require('basic-auth');\n\nvar debug = require('debug')('morgan');\n\nvar deprecate = require('depd')('morgan');\n\nvar onFinished = require('on-finished');\n\nvar onHeaders = require('on-headers');\n/**\n * Array of CLF month names.\n * @private\n */\n\n\nvar CLF_MONTH = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n/**\n * Default log buffer duration.\n * @private\n */\n\nvar DEFAULT_BUFFER_DURATION = 1000;\n/**\n * Create a logger middleware.\n *\n * @public\n * @param {String|Function} format\n * @param {Object} [options]\n * @return {Function} middleware\n */\n\nfunction morgan(format, options) {\n  var fmt = format;\n  var opts = options || {};\n\n  if (format && typeof format === 'object') {\n    opts = format;\n    fmt = opts.format || 'default'; // smart deprecation message\n\n    deprecate('morgan(options): use morgan(' + (typeof fmt === 'string' ? JSON.stringify(fmt) : 'format') + ', options) instead');\n  }\n\n  if (fmt === undefined) {\n    deprecate('undefined format: specify a format');\n  } // output on request instead of response\n\n\n  var immediate = opts.immediate; // check if log entry should be skipped\n\n  var skip = opts.skip || false; // format function\n\n  var formatLine = typeof fmt !== 'function' ? getFormatFunction(fmt) : fmt; // stream\n\n  var buffer = opts.buffer;\n  var stream = opts.stream || process.stdout; // buffering support\n\n  if (buffer) {\n    deprecate('buffer option'); // flush interval\n\n    var interval = typeof buffer !== 'number' ? DEFAULT_BUFFER_DURATION : buffer; // swap the stream\n\n    stream = createBufferStream(stream, interval);\n  }\n\n  return function logger(req, res, next) {\n    // request data\n    req._startAt = undefined;\n    req._startTime = undefined;\n    req._remoteAddress = getip(req); // response data\n\n    res._startAt = undefined;\n    res._startTime = undefined; // record request start\n\n    recordStartTime.call(req);\n\n    function logRequest() {\n      if (skip !== false && skip(req, res)) {\n        debug('skip request');\n        return;\n      }\n\n      var line = formatLine(morgan, req, res);\n\n      if (line == null) {\n        debug('skip line');\n        return;\n      }\n\n      debug('log request');\n      stream.write(line + '\\n');\n    }\n\n    ;\n\n    if (immediate) {\n      // immediate log\n      logRequest();\n    } else {\n      // record response start\n      onHeaders(res, recordStartTime); // log when response finished\n\n      onFinished(res, logRequest);\n    }\n\n    next();\n  };\n}\n/**\n * Apache combined log format.\n */\n\n\nmorgan.format('combined', ':remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"');\n/**\n * Apache common log format.\n */\n\nmorgan.format('common', ':remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length]');\n/**\n * Default format.\n */\n\nmorgan.format('default', ':remote-addr - :remote-user [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"');\ndeprecate.property(morgan, 'default', 'default format: use combined format');\n/**\n * Short format.\n */\n\nmorgan.format('short', ':remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms');\n/**\n * Tiny format.\n */\n\nmorgan.format('tiny', ':method :url :status :res[content-length] - :response-time ms');\n/**\n * dev (colored)\n */\n\nmorgan.format('dev', function developmentFormatLine(tokens, req, res) {\n  // get the status code if response written\n  var status = headersSent(res) ? res.statusCode : undefined; // get status color\n\n  var color = status >= 500 ? 31 // red\n  : status >= 400 ? 33 // yellow\n  : status >= 300 ? 36 // cyan\n  : status >= 200 ? 32 // green\n  : 0; // no color\n  // get colored function\n\n  var fn = developmentFormatLine[color];\n\n  if (!fn) {\n    // compile\n    fn = developmentFormatLine[color] = compile('\\x1b[0m:method :url \\x1b[' + color + 'm:status \\x1b[0m:response-time ms - :res[content-length]\\x1b[0m');\n  }\n\n  return fn(tokens, req, res);\n});\n/**\n * request url\n */\n\nmorgan.token('url', function getUrlToken(req) {\n  return req.originalUrl || req.url;\n});\n/**\n * request method\n */\n\nmorgan.token('method', function getMethodToken(req) {\n  return req.method;\n});\n/**\n * response time in milliseconds\n */\n\nmorgan.token('response-time', function getResponseTimeToken(req, res, digits) {\n  if (!req._startAt || !res._startAt) {\n    // missing request and/or response start time\n    return;\n  } // calculate diff\n\n\n  var ms = (res._startAt[0] - req._startAt[0]) * 1e3 + (res._startAt[1] - req._startAt[1]) * 1e-6; // return truncated value\n\n  return ms.toFixed(digits === undefined ? 3 : digits);\n});\n/**\n * current date\n */\n\nmorgan.token('date', function getDateToken(req, res, format) {\n  var date = new Date();\n\n  switch (format || 'web') {\n    case 'clf':\n      return clfdate(date);\n\n    case 'iso':\n      return date.toISOString();\n\n    case 'web':\n      return date.toUTCString();\n  }\n});\n/**\n * response status code\n */\n\nmorgan.token('status', function getStatusToken(req, res) {\n  return headersSent(res) ? String(res.statusCode) : undefined;\n});\n/**\n * normalized referrer\n */\n\nmorgan.token('referrer', function getReferrerToken(req) {\n  return req.headers['referer'] || req.headers['referrer'];\n});\n/**\n * remote address\n */\n\nmorgan.token('remote-addr', getip);\n/**\n * remote user\n */\n\nmorgan.token('remote-user', function getRemoteUserToken(req) {\n  // parse basic credentials\n  var credentials = auth(req); // return username\n\n  return credentials ? credentials.name : undefined;\n});\n/**\n * HTTP version\n */\n\nmorgan.token('http-version', function getHttpVersionToken(req) {\n  return req.httpVersionMajor + '.' + req.httpVersionMinor;\n});\n/**\n * UA string\n */\n\nmorgan.token('user-agent', function getUserAgentToken(req) {\n  return req.headers['user-agent'];\n});\n/**\n * request header\n */\n\nmorgan.token('req', function getRequestToken(req, res, field) {\n  // get header\n  var header = req.headers[field.toLowerCase()];\n  return Array.isArray(header) ? header.join(', ') : header;\n});\n/**\n * response header\n */\n\nmorgan.token('res', function getResponseHeader(req, res, field) {\n  if (!headersSent(res)) {\n    return undefined;\n  } // get header\n\n\n  var header = res.getHeader(field);\n  return Array.isArray(header) ? header.join(', ') : header;\n});\n/**\n * Format a Date in the common log format.\n *\n * @private\n * @param {Date} dateTime\n * @return {string}\n */\n\nfunction clfdate(dateTime) {\n  var date = dateTime.getUTCDate();\n  var hour = dateTime.getUTCHours();\n  var mins = dateTime.getUTCMinutes();\n  var secs = dateTime.getUTCSeconds();\n  var year = dateTime.getUTCFullYear();\n  var month = CLF_MONTH[dateTime.getUTCMonth()];\n  return pad2(date) + '/' + month + '/' + year + ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs) + ' +0000';\n}\n/**\n * Compile a format string into a function.\n *\n * @param {string} format\n * @return {function}\n * @public\n */\n\n\nfunction compile(format) {\n  if (typeof format !== 'string') {\n    throw new TypeError('argument format must be a string');\n  }\n\n  var fmt = String(JSON.stringify(format));\n  var js = '  \"use strict\"\\n  return ' + fmt.replace(/:([-\\w]{2,})(?:\\[([^\\]]+)\\])?/g, function (_, name, arg) {\n    var tokenArguments = 'req, res';\n    var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']';\n\n    if (arg !== undefined) {\n      tokenArguments += ', ' + String(JSON.stringify(arg));\n    }\n\n    return '\" +\\n    (' + tokenFunction + '(' + tokenArguments + ') || \"-\") + \"';\n  }); // eslint-disable-next-line no-new-func\n\n  return new Function('tokens, req, res', js);\n}\n/**\n * Create a basic buffering stream.\n *\n * @param {object} stream\n * @param {number} interval\n * @public\n */\n\n\nfunction createBufferStream(stream, interval) {\n  var buf = [];\n  var timer = null; // flush function\n\n  function flush() {\n    timer = null;\n    stream.write(buf.join(''));\n    buf.length = 0;\n  } // write function\n\n\n  function write(str) {\n    if (timer === null) {\n      timer = setTimeout(flush, interval);\n    }\n\n    buf.push(str);\n  } // return a minimal \"stream\"\n\n\n  return {\n    write: write\n  };\n}\n/**\n * Define a format with the given name.\n *\n * @param {string} name\n * @param {string|function} fmt\n * @public\n */\n\n\nfunction format(name, fmt) {\n  morgan[name] = fmt;\n  return this;\n}\n/**\n * Lookup and compile a named format function.\n *\n * @param {string} name\n * @return {function}\n * @public\n */\n\n\nfunction getFormatFunction(name) {\n  // lookup format\n  var fmt = morgan[name] || name || morgan.default; // return compiled format\n\n  return typeof fmt !== 'function' ? compile(fmt) : fmt;\n}\n/**\n * Get request IP address.\n *\n * @private\n * @param {IncomingMessage} req\n * @return {string}\n */\n\n\nfunction getip(req) {\n  return req.ip || req._remoteAddress || req.connection && req.connection.remoteAddress || undefined;\n}\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\n\nfunction headersSent(res) {\n  return typeof res.headersSent !== 'boolean' ? Boolean(res._header) : res.headersSent;\n}\n/**\n * Pad number to two digits.\n *\n * @private\n * @param {number} num\n * @return {string}\n */\n\n\nfunction pad2(num) {\n  var str = String(num);\n  return (str.length === 1 ? '0' : '') + str;\n}\n/**\n * Record the start time.\n * @private\n */\n\n\nfunction recordStartTime() {\n  this._startAt = process.hrtime();\n  this._startTime = new Date();\n}\n/**\n * Define a token function with the given name,\n * and callback fn(req, res).\n *\n * @param {string} name\n * @param {function} fn\n * @public\n */\n\n\nfunction token(name, fn) {\n  morgan[name] = fn;\n  return this;\n}","map":null,"metadata":{},"sourceType":"script"}