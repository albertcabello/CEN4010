{"ast":null,"code":"var Util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Packets = require('../packets');\n\nvar ErrorConstants = require('../constants/errors');\n\nvar Timer = require('../Timer'); // istanbul ignore next: Node.js < 0.10 not covered\n\n\nvar listenerCount = EventEmitter.listenerCount || function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n\nvar LONG_STACK_DELIMITER = '\\n    --------------------\\n';\nmodule.exports = Sequence;\nUtil.inherits(Sequence, EventEmitter);\n\nfunction Sequence(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  EventEmitter.call(this);\n  options = options || {};\n  this._callback = callback;\n  this._callSite = null;\n  this._ended = false;\n  this._timeout = options.timeout;\n  this._timer = new Timer(this);\n}\n\nSequence.determinePacket = function (byte) {\n  switch (byte) {\n    case 0x00:\n      return Packets.OkPacket;\n\n    case 0xfe:\n      return Packets.EofPacket;\n\n    case 0xff:\n      return Packets.ErrorPacket;\n\n    default:\n      return undefined;\n  }\n};\n\nSequence.prototype.hasErrorHandler = function () {\n  return Boolean(this._callback) || listenerCount(this, 'error') > 1;\n};\n\nSequence.prototype._packetToError = function (packet) {\n  var code = ErrorConstants[packet.errno] || 'UNKNOWN_CODE_PLEASE_REPORT';\n  var err = new Error(code + ': ' + packet.message);\n  err.code = code;\n  err.errno = packet.errno;\n  err.sqlMessage = packet.message;\n  err.sqlState = packet.sqlState;\n  return err;\n};\n\nSequence.prototype.end = function (err) {\n  if (this._ended) {\n    return;\n  }\n\n  this._ended = true;\n\n  if (err) {\n    this._addLongStackTrace(err);\n  } // Without this we are leaking memory. This problem was introduced in\n  // 8189925374e7ce3819bbe88b64c7b15abac96b16. I suspect that the error object\n  // causes a cyclic reference that the GC does not detect properly, but I was\n  // unable to produce a standalone version of this leak. This would be a great\n  // challenge for somebody interested in difficult problems : )!\n\n\n  this._callSite = null; // try...finally for exception safety\n\n  try {\n    if (err) {\n      this.emit('error', err);\n    }\n  } finally {\n    try {\n      if (this._callback) {\n        this._callback.apply(this, arguments);\n      }\n    } finally {\n      this.emit('end');\n    }\n  }\n};\n\nSequence.prototype['OkPacket'] = function (packet) {\n  this.end(null, packet);\n};\n\nSequence.prototype['ErrorPacket'] = function (packet) {\n  this.end(this._packetToError(packet));\n}; // Implemented by child classes\n\n\nSequence.prototype.start = function () {};\n\nSequence.prototype._addLongStackTrace = function _addLongStackTrace(err) {\n  var callSiteStack = this._callSite && this._callSite.stack;\n\n  if (!callSiteStack || typeof callSiteStack !== 'string') {\n    // No recorded call site\n    return;\n  }\n\n  if (err.stack.indexOf(LONG_STACK_DELIMITER) !== -1) {\n    // Error stack already looks long\n    return;\n  }\n\n  var index = callSiteStack.indexOf('\\n');\n\n  if (index !== -1) {\n    // Append recorded call site\n    err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);\n  }\n};\n\nSequence.prototype._onTimeout = function _onTimeout() {\n  this.emit('timeout');\n};","map":null,"metadata":{},"sourceType":"script"}